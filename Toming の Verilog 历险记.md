# Toming の Verilog 历险记

## 一、模块结构

### 模块介绍

```verilog
//1 端口定义
module module_name(端口名1,端口名2,...);
    
    //2 参数定义(可选)
    parameter 参数名 = 参数值;	//适用场景:例如定义信号位宽	
    						   //类似C/C++中的宏定义 #define
    
    //3 I/O说明
    //输入端口
    input 端口名1;
    input [信号位宽-1 : 0] 端口名2;
    ...;
    //输出端口
    output 端口名1;
    output [信号位宽-1 : 0] 端口名2;
    ...;
    //双向端口
    inout 端口名1;
    inout [信号位宽-1 : 0] 端口名2;
    ...;
    
    //4 内部信号声名
    //reg寄存器型
    reg[信号位宽-1 : 0] R 变量1, R 变量2 ......;
    //wire线型
    wire[信号位宽 1 : 0] W 变量1, W 变量2 ......;
    
    //5 功能定义
 	//assign
    //always
    //模块例化	//类似C/C++中类的实例化
endmodule
```

### 模块例化

```verilog
module and (C,A,B);
    input A,B;
    output C;
    //忽略
endmodule

//在下面的"and_2"块中对上一模块"and"进行例化,可以有两种方式：
module and_2(xxxxx);
    ...
	//方式一:实例化时采用位置关联，例如此处T3对应输出端口C,A对应A,B对应B
    and A1(T3,A,B);
    //方式二:实例化时采用名字关联，例如此处.C是and器件的端口,其与信号T3相连(推荐使用)
    and A2（
    	.C(T3),
    	.A(A),
    	.B(B)
    );
    ...
endmodule
```

## 二、信号类型

### 信号位宽

​		默认信号的位宽是1位。当信号的位宽为1时可不表述，例如`wire a;`。但当信号位宽大于1时就一定要表示出来，例`wire [7:0]`就表示该wire型信号的位宽为8位。

​		信号的位宽取决于要该信号表示的最大值。n信号位宽的信号能表示的无符号数最大值是$2^n-1$

### 线网类型 wire

​		线网类型用于对结构化器件之间的物理连线的建模，如器件的管脚，芯片内部器件如与门的输出等。由于线网类型代表的是物理连接线，因此其不存储逻辑值，必须由器件驱动。通常用assign进行赋值，例如`assign A = B ^ C`

​		如果未定义信号类型，则默认为线网类型。

### 寄存器类型reg

​		reg是最常用的寄存器类型，寄存器类型通常用于存储单元的描述，如D型触发器、ROM等。寄存器类型信号的特点是在某种触发机制下分配了一个值，在下一触发机制到来之前保留原值。但必须注意的是：reg类型的变量不一定是存储单元，如在always语句中进行描述的必须是reg类型的变量。

### wire和reg的区别

​		wire表示直通，即输入由变化，输出马上无条件的反映。reg表示一定要有触发，输出才会反映输入的状态。

​		wire数据需要持续的驱动，而reg型数据保持最后一次的赋值。

​		wire使用在连续赋值语句中，而reg使用在过程赋值语句（initial ，always）中。

## 三、程序语句

### assign语句

​		assign语句是连续赋值语句，一般是将一个变量的值不间断地赋值给另一个变量，类似于被导线连在一起。

```verilog
assign a=b;
```

​		如果要用assign直接连接，就用wire型变量，wire型变量的值随时发生变化。

### always语句

​		always语句是条件循环语句，执行机制是通过对一个敏感变量事件驱动来实现的。always语句基本格式是：

```verilog
always @(敏感事件)begin
	程序语句
end
```

​		当敏感事件的条件满足一次时，就执行一次“程序语句”。

```verilog
always @(*)begin
	程序语句
end
```

​		当敏感信号非常多很容易就会把敏感信号遗漏，为了避免这个情况可以用"\*"代替，这个"\*"是指“程序语句”中所有的条件信号。

​		当逻辑条件为`posedge clk`时，代表的时当clk上升沿时触发。`posedge`即意为上升沿有效。同理`negedge`即为下降沿有效。

```
always @(posedge clk,negedge rst)begin
	if(rst==0)begin
		c<=0;
	end else begin
end
```



