# Toming の Verilog 历险记

## 一、模块结构

### 模块介绍

```verilog
//1 端口定义
module module_name(端口名1,端口名2,...);
    
    //2 参数定义(可选)
    parameter 参数名 = 参数值;	//适用场景:例如定义信号位宽	
    						   //类似C/C++中的宏定义 #define
    
    //3 I/O说明
    //输入端口
    input 端口名1;
    input [信号位宽-1 : 0] 端口名2;
    ...;
    //输出端口
    output 端口名1;
    output [信号位宽-1 : 0] 端口名2;
    ...;
    //双向端口
    inout 端口名1;
    inout [信号位宽-1 : 0] 端口名2;
    ...;
    
    //4 内部信号声名
    //reg寄存器型
    reg[信号位宽-1 : 0] R 变量1, R 变量2 ......;
    //wire线型
    wire[信号位宽 1 : 0] W 变量1, W 变量2 ......;
    
    //5 功能定义
 	//assign
    //always
    //模块例化	//类似C/C++中类的实例化
endmodule
```

### 模块例化

```verilog
module and (C,A,B);
    input A,B;
    output C;
    //忽略
endmodule

//在下面的"and_2"块中对上一模块"and"进行例化,可以有两种方式：
module and_2(xxxxx);
    ...
	//方式一:实例化时采用位置关联，例如此处T3对应输出端口C,A对应A,B对应B
    and A1(T3,A,B);
    //方式二:实例化时采用名字关联，例如此处.C是and器件的端口,其与信号T3相连(推荐使用)
    and A2（
    	.C(T3),
    	.A(A),
    	.B(B)
    );
    ...
endmodule
```

## 二、信号类型

### 信号位宽

​		默认信号的位宽是1位。当信号的位宽为1时可不表述，例如`wire a;`。但当信号位宽大于1时就一定要表示出来，例`wire [7:0]`就表示该wire型信号的位宽为8位。

​		信号的位宽取决于要该信号表示的最大值。n信号位宽的信号能表示的无符号数最大值是$2^n-1$

### 线网类型 wire

​		线网类型用于对结构化器件之间的物理连线的建模，如器件的管脚，芯片内部器件如与门的输出等。由于线网类型代表的是物理连接线，因此其不存储逻辑值，必须由器件驱动。通常用assign进行赋值，例如`assign A = B ^ C`

​		如果未定义信号类型，则默认为线网类型。

### 寄存器类型reg

​		reg是最常用的寄存器类型，寄存器类型通常用于存储单元的描述，如D型触发器、ROM等。寄存器类型信号的特点是在某种触发机制下分配了一个值，在下一触发机制到来之前保留原值。但必须注意的是：reg类型的变量不一定是存储单元，如在always语句中进行描述的必须是reg类型的变量。

### wire和reg的区别

​		wire表示直通，即输入由变化，输出马上无条件的反映。reg表示一定要有触发，输出才会反映输入的状态。

​		wire数据需要持续的驱动，而reg型数据保持最后一次的赋值。

​		wire使用在连续赋值语句中，而reg使用在过程赋值语句（initial ，always）中。

## 三、程序语句

### assign语句

​		assign语句是连续赋值语句，一般是将一个变量的值不间断地赋值给另一个变量，类似于被导线连在一起。

```verilog
assign a=b;
```

​		如果要用assign直接连接，就用wire型变量，wire型变量的值随时发生变化。

### always语句

​		always语句是条件循环语句，执行机制是通过对一个敏感变量事件驱动来实现的。always语句基本格式是：

```verilog
always @(敏感事件)begin
	程序语句
end
```

​		当敏感事件的条件满足一次时，就执行一次“程序语句”。

```verilog
always @(*)begin
	程序语句
end
```

​		当敏感信号非常多很容易就会把敏感信号遗漏，为了避免这个情况可以用"\*"代替，这个"\*"是指“程序语句”中所有的条件信号。

​		当逻辑条件为`posedge clk`时，代表的时当clk上升沿时触发。`posedge`即意为上升沿有效。同理`negedge`即为下降沿有效。

​		此处‘<=’意思为非阻塞赋值，常用在时序逻辑器件中。

```
always @(posedge clk,negedge rst)begin
	if(rst==0)begin
		c<=0;
	end else begin
end
```

## 四、数字进制

### 数字表示方式

​		在Verilog中的数字表示方式，最常用的格式是：<位宽>'<基数><数值>

​		位宽：描述常量所含位数的十进制整数，是可选项。例如4‘b1011中的4就是位宽。如何没有这一项可以通过常量的值进行推断，例如’b1011可推断出位宽是4。

​		基数：表示数值是什么进制。不区分大小写。如果没有此项，则缺省默认为十进制数。在二进制中，还额外有x和z，分别表示不定态和高阻态。

| 字母 | 表示进制 |
| :--: | :------: |
| b,B  |  二进制  |
| d,D  |  十进制  |
| o,O  |  八进制  |
| h,H  | 十六进制 |

​		数值：是由基数所决定的表示常量真实值的一串ASCLL码。当数值未写完整时，高位补零。当数值超过所能表示长度时，取低位。

## 五、条件运算符

### case语句

语法和C/C++中的switch语法类似。

```verilog
always @(*)begin
	case(S)
	常量表达式1 : 语句1;
	常量表达式2 : 语句2;
	常量表达式3 : 语句3;
	...
    default : 语句4;	//可省略 
end
```

### if语句

语法和C/C++类似。

```verilog
//格式1
if(条件)
	语句1;
else
	语句2;

//格式2
if(条件1)begin
	语句1
	语句2
	...
end else begin
	语句3
	语句4
	...
end
```

### 选择语句

​		语法形式：`vect[a+:b]`或`vect[a-:b]`

​		其中，vect为变量名字，a为起始位置，加号或减号代表着升序或者降序，b代表进行升序或者降序的宽度。例如`vect[7+:3]==vect[7:9]`而`vect[9-:4]==vect[9:6]`

## 六、拼接运算符

 

